---
import songs from '../data/data_cleaned.json';
import '../styles/global.css';
import '../styles/index.css';
import { pwaInfo } from 'virtual:pwa-info';

export interface Props {
  title: string;
}

const { title } = Astro.props as Props;
---

<html lang="ta">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/pwa-192x192.png">
    <link rel="mask-icon" href="/favicon.svg" color="#FFFFFF">
    <meta name="msapplication-TileColor" content="#FFFFFF">
    <meta name="theme-color" content="#ffffff">
    <title>{title}</title>
    <meta name="description" content={title}>
    <script src="/src/pwa.ts"></script>
    { pwaInfo && <Fragment set:html={pwaInfo.webManifest.linkTag} /> }
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Tamil:wght@100..900&display=swap" rel="stylesheet">
    <!-- Include Material Icons from Google Fonts -->
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  </head>
  <body class="bg-gray-100 font-tamil">
    <!-- Outer container -->
    <div class="w-full px-4 py-8 sm:container sm:mx-auto">
      
      <!-- Increase the top margin for the title -->
      <h1 class="mt-2 mb-6 lg:mt-8 text-3xl md:text-4xl font-extrabold text-center text-darkblue lg:mb-12 leading-snug">
        Tamil Christian Songs
      </h1>
  
<!-- Include Material Icons from Google Fonts -->

<div class="search-bar relative mb-8 flex items-center">
  <!-- Language Dropdown inside search bar -->
  <select id="search-lang-select" class="mr-4 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-babyblue">
    <option value="none">Tamil</option>
    <option value="en">English</option>
    <option value="de">German</option>
  </select>
  
  <div class="flex-grow relative">
    <!-- Search Icon using Material Icons -->
    <span class="search-icon">
      <!-- Inline SVG for search icon -->
      <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none"
           viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
          d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
      </svg>
    </span>
    
    <input
      id="searchInput"
      type="text"
      placeholder="Search songs..."
      class="w-full pl-12 px-4 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-babyblue"
    />
    
    <!-- Cancel Button without border -->
    <button
      id="clearButton"
      type="button"
      class="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 rounded-md p-1 hidden focus:outline-none"
      aria-label="Clear search"
    >
      <span class="material-icons">cancel</span>
    </button>
  </div>
</div>


      <!-- Songs List -->
      <ul class="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3" id="songsList">
        {songs.map((song, index) => (
          <li
            key={song.id}
            data-id={song.id}  {/* Added data-id */}
            data-index={index}
            data-title={song.title}
            data-text={song.text}
            data-title-en={song.title_en}
            data-text-en={song.text_en}
            data-title-de={song.title_de}
            data-text-de={song.text_de}
            class="song-item w-full bg-white rounded-lg shadow hover:shadow-lg transition-shadow p-4"
          >
            <a href={`${import.meta.env.BASE_URL}/songs/${song.id}`} class="block h-full">
              <div class="title-container">
                <div class="translation-title hidden text-sm text-gray-600"></div>
                <div class="original-title text-base md:text-lg lg:text-xl font-medium text-gray-800 hover:text-deapseablue transition-colors">
                  {song.title}
                </div>
              </div>
              <div class="text-snippet text-sm text-gray-500 mt-1"></div>
            </a>
          </li>
        ))}    
      </ul>
    </div>
  
    <!-- Go to Top Button -->
    <button id="goToTopButton" class="fixed bottom-4 right-4 bg-babyblue text-white rounded-full shadow-lg p-3 hover:bg-wallpaintblue focus:outline-none flex items-center justify-center hidden">
      <span class="hidden sm:flex items-center justify-center">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none"
             viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
        </svg>
        <span class="ml-2">Go to Top</span>
      </span>
      <span class="sm:hidden flex items-center justify-center">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none"
             viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
        </svg>
      </span>
    </button>
  
    <script>
      // Utility functions
      const escapeRegExp = str => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const cleanText = text => text.normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/(\\n|\r\n|\n|\r)/g, ' ').replace(/\s+/g, ' ').trim();
      const highlight = (text, query) => {
        if (!query) return text;
        text = cleanText(text);
        const words = query.split(/\s+/).filter(Boolean);
        const regex = new RegExp('(' + words.map(escapeRegExp).join('|') + ')', 'giu');
        return text.replace(regex, '<span class="highlighted bg-yellow-200">$1</span>');
      };
      const getSnippet = (text, query, snippetLength = 50) => {
        if (!query) return '';
        const cleaned = cleanText(text);
        const lowerText = cleaned.toLowerCase();
        const queryWords = query.split(/\s+/).filter(Boolean);
        let firstIndex = Infinity;
        queryWords.forEach(word => {
          const i = lowerText.indexOf(word.toLowerCase());
          if (i !== -1 && i < firstIndex) firstIndex = i;
        });
        if (firstIndex === Infinity) return '';
        let start = Math.max(0, firstIndex - snippetLength);
        let end = Math.min(cleaned.length, firstIndex + snippetLength + queryWords[0].length);
        if (start > 0) {
          const prevSpace = cleaned.lastIndexOf(' ', start);
          if (prevSpace !== -1) start = prevSpace + 1;
        }
        if (end < cleaned.length) {
          const nextSpace = cleaned.indexOf(' ', end);
          if (nextSpace !== -1) end = nextSpace;
        }
        let snippet = cleaned.substring(start, end);
        if (start > 0) snippet = '...' + snippet;
        if (end < cleaned.length) snippet = snippet + '...';
        return highlight(snippet, query);
      };
  
      // Get DOM elements
      const searchLangSelect = document.getElementById('search-lang-select');
      const searchInput = document.getElementById('searchInput');
      const clearButton = document.getElementById('clearButton');
      const songsList = document.getElementById('songsList');
      const songItems = Array.from(document.querySelectorAll('.song-item'));
  
      // Use the search language dropdown value as the current language.
      let currentLang = sessionStorage.getItem('selectedLanguage') || searchLangSelect.value;
      searchLangSelect.value = currentLang;
  
      // Utility: update all song links with the proper language parameter
      const updateSongLinks = () => {
        songItems.forEach(item => {
          const songId = item.getAttribute('data-id');
          const link = item.querySelector('a');
          const langForLink = (currentLang === 'none' ? 'ta' : currentLang);
          link.href = `${import.meta.env.BASE_URL}/songs/${songId}?lang=${langForLink}`;
        });
      };
  
      // When the search language dropdown changes, update currentLang and reapply search if needed.
      searchLangSelect.addEventListener('change', (e) => {
        currentLang = e.target.value;
        sessionStorage.setItem('selectedLanguage', currentLang);
        const query = searchInput.value.trim();
        if (query !== '') {
          filterSongs(query, currentLang);
        } else {
          resetOriginalOrder();
          updateTitles();
        }
        updateSongLinks();
      });
  
      // Update resetOriginalOrder to update links using currentLang
      const resetOriginalOrder = () => {
        songItems.sort((a, b) =>
          Number(a.getAttribute('data-index')) - Number(b.getAttribute('data-index'))
        );
        songsList.innerHTML = '';
        songItems.forEach(item => {
          item.querySelector('.original-title').innerHTML = item.getAttribute('data-title') || '';
          if (currentLang === 'en') {
            item.querySelector('.translation-title').innerHTML = item.getAttribute('data-title-en') || '';
            item.querySelector('.translation-title').classList.remove('hidden');
          } else if (currentLang === 'de') {
            item.querySelector('.translation-title').innerHTML = item.getAttribute('data-title-de') || '';
            item.querySelector('.translation-title').classList.remove('hidden');
          } else {
            item.querySelector('.translation-title').classList.add('hidden');
          }
          item.querySelector('.text-snippet').innerHTML = '';
          item.style.display = '';
          songsList.appendChild(item);
          const songId = item.getAttribute('data-id');
          const link = item.querySelector('a');
          const langForLink = (currentLang === 'none' ? 'ta' : currentLang);
          link.href = `${import.meta.env.BASE_URL}/songs/${songId}?lang=${langForLink}`;
        });
      };
  
      // Filter function now only searches in the fields for the provided language.
      // The function now receives the language (currentLang) as the second argument.
      const filterSongs = (query, searchLang) => {
        query = query.trim().toLowerCase();
        if (query === '') {
          resetOriginalOrder();
          updateTitles();
          return;
        }
  
        let fieldKeyTitle, fieldKeyText;
        if (searchLang === 'none') {
          fieldKeyTitle = 'data-title';
          fieldKeyText = 'data-text';
        } else if (searchLang === 'en') {
          fieldKeyTitle = 'data-title-en';
          fieldKeyText = 'data-text-en';
        } else if (searchLang === 'de') {
          fieldKeyTitle = 'data-title-de';
          fieldKeyText = 'data-text-de';
        }
  
        let resultsFound = false;
        songItems.forEach(li => {
          const titleField = li.getAttribute(fieldKeyTitle) || '';
          const textField = li.getAttribute(fieldKeyText) || '';
          const titleHit = titleField.toLowerCase().includes(query);
          const textHit = textField.toLowerCase().includes(query);
  
          if (titleHit || textHit) {
            li.style.display = '';
            if (searchLang === 'none') {
              li.querySelector('.original-title').innerHTML = titleHit
                ? highlight(li.getAttribute('data-title') || '', query)
                : li.getAttribute('data-title');
              li.querySelector('.text-snippet').innerHTML = textHit
                ? getSnippet(li.getAttribute('data-text') || '', query)
                : '';
              li.querySelector('.translation-title').classList.add('hidden');
            } else {
              let displayTitle = li.getAttribute(fieldKeyTitle) || '';
              let displayText = li.getAttribute(fieldKeyText) || '';
              // No language label is added in search results.
              li.querySelector('.translation-title').innerHTML = titleHit
                ? highlight(displayTitle, query)
                : displayTitle;
              li.querySelector('.translation-title').classList.remove('hidden');
              li.querySelector('.original-title').innerHTML = li.getAttribute('data-title');
              li.querySelector('.text-snippet').innerHTML = textHit
                ? getSnippet(displayText, query)
                : '';
            }
  
            const songId = li.getAttribute('data-id');
            const link = li.querySelector('a');
            const langForLink = searchLang === 'none' ? 'ta' : searchLang;
            link.href = `${import.meta.env.BASE_URL}/songs/${songId}?lang=${langForLink}`;
            resultsFound = true;
          } else {
            li.style.display = 'none';
          }
        });
  
        if (!resultsFound) {
          songItems.forEach(li => li.style.display = 'none');
        }
      };
  
      // Debounce helper.
      const debounce = (fn, delay) => {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn(...args), delay);
        };
      };
  
      const debouncedFilter = debounce(() => {
        const query = searchInput.value;
        sessionStorage.setItem('searchQuery', query);
        filterSongs(query, searchLangSelect.value);
        clearButton.style.display = query.trim() !== '' ? 'block' : 'none';
        updateTitles();
      }, 300);
  
      const savedQuery = sessionStorage.getItem('searchQuery');
      if (savedQuery) {
        searchInput.value = savedQuery;
        filterSongs(savedQuery, searchLangSelect.value);
        if (savedQuery.trim() !== '') clearButton.style.display = 'block';
      }
  
      searchInput.addEventListener('input', debouncedFilter);
      clearButton.addEventListener('click', () => {
        searchInput.value = '';
        sessionStorage.removeItem('searchQuery');
        resetOriginalOrder();
        clearButton.style.display = 'none';
      });
  
      const goToTopButton = document.getElementById('goToTopButton');
      window.addEventListener('scroll', () => {
        goToTopButton.style.display = window.scrollY > 300 ? 'block' : 'none';
      });
      goToTopButton.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
  
      window.addEventListener('pageshow', () => {
        const savedQuery = sessionStorage.getItem('searchQuery') || '';
        if (savedQuery.trim() !== '') {
          searchInput.value = savedQuery;
          setTimeout(() => {
            filterSongs(savedQuery, searchLangSelect.value);
            clearButton.style.display = 'block';
          }, 0);
        }
        const savedLang = sessionStorage.getItem('selectedLanguage') || 'none';
        searchLangSelect.value = savedLang;
        currentLang = savedLang;
        resetOriginalOrder();
        updateTitles();
        updateSongLinks();
      });
  
      // Dummy updateTitles() â€“ implement as needed.
      function updateTitles() {
        // Implementation placeholder
      }


// Add this to your songbook page's initialization code
document.addEventListener('DOMContentLoaded', () => {
  // Check if we're returning from a song page
  const returnedFromSong = sessionStorage.getItem('returnedFromSong');
  
  if (returnedFromSong) {
    // Get the saved scroll position
    const savedScrollPosition = sessionStorage.getItem('songbookScrollPosition');
    
    if (savedScrollPosition) {
      // Restore the scroll position
      window.scrollTo(0, parseInt(savedScrollPosition, 10));
    }
    
    // Clear the flag and scroll position after use
    sessionStorage.removeItem('returnedFromSong');
  }
});

// Add this to capture scroll position when user clicks on a song
// This should be attached to all song links in your songbook page
function saveScrollPosition() {
  sessionStorage.setItem('songbookScrollPosition', window.scrollY.toString());
}

// Add this event to your window object in the songbook page
window.addEventListener('scroll', () => {
  // Debounce this for better performance if needed
  sessionStorage.setItem('songbookScrollPosition', window.scrollY.toString());
});
    </script>
  </body>
</html>
