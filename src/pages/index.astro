---
import songs from '../data/data_cleaned.json';
import '../styles/global.css';
import '../styles/index.css';
import { pwaInfo } from 'virtual:pwa-info';

export interface Props {
  title: string;
}

const { title } = Astro.props as Props;
---

<!DOCTYPE html>
<html lang="ta">
  <!-- Blocking script in the head to prevent flash -->
  <script is:inline>
    // Check theme preference and apply it immediately
    const savedTheme = localStorage.getItem('theme');
    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (savedTheme === 'dark' || (!savedTheme && systemPrefersDark)) {
      document.documentElement.classList.add('dark');
    }

    // theme-toggle.js
document.addEventListener('DOMContentLoaded', () => {
    // Check for saved theme preference or use the system preference
    const savedTheme = localStorage.getItem('theme');
    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    // Apply the theme based on saved preference or system preference
    if (savedTheme === 'dark' || (!savedTheme && systemPrefersDark)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
    
    // Update the toggle button's state
    updateToggleState();
    
    // Add event listener to the theme toggle button
    const themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
      themeToggle.addEventListener('click', () => {
        // Toggle the dark class on the html element
        document.documentElement.classList.toggle('dark');
        
        // Save the current preference to localStorage
        const isDark = document.documentElement.classList.contains('dark');
        localStorage.setItem('theme', isDark ? 'dark' : 'light');
        
        // Update the toggle button's state
        updateToggleState();
      });
    }
  });
  
  // Update the toggle button to reflect the current theme
  function updateToggleState() {
    const themeToggle = document.getElementById('theme-toggle');
    const isDark = document.documentElement.classList.contains('dark');
    
    if (themeToggle) {
      const sunIcon = themeToggle.querySelector('.sun-icon');
      const moonIcon = themeToggle.querySelector('.moon-icon');
      
      if (sunIcon && moonIcon) {
        if (isDark) {
          sunIcon.classList.remove('hidden');
          moonIcon.classList.add('hidden');
        } else {
          sunIcon.classList.add('hidden');
          moonIcon.classList.remove('hidden');
        }
      }
    }
  }
  </script>
 <!-- Changes to the <head> section for improved SEO -->

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- Favicon and App Icons -->
  <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
  <link rel="apple-touch-icon" href="/pwa-192x192.png" />
  <link rel="mask-icon" href="/favicon.svg" color="#6366F1" />
  
  <!-- Theme Colors -->
  <meta name="msapplication-TileColor" content="#6366F1" />
  <meta name="theme-color" content="#6366F1" media="(prefers-color-scheme: light)" />
  <meta name="theme-color" content="#1F2937" media="(prefers-color-scheme: dark)" />
  
  <!-- SEO Meta Tags -->
  <title>Tamil Christian Songs</title>
  <meta name="description" content="Browse a comprehensive collection of Tamil Christian songs with translations in English and German. Search by title, lyrics, or content." />
  <meta name="keywords" content="Tamil Christian songs, Tamil worship songs, Christian music, Tamil devotional songs, Tamil hymns, Christian worship" />
  <meta name="author" content="Tamil Christian Songbook" />
  
  <!-- Open Graph / Social Media Tags -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://sujant-h.github.io/songbook/" />
  <meta property="og:title" content="Tamil Christian Songs Collection" />
  <meta property="og:description" content="A collection of beautiful Tamil Christian songs with translations in English and German" />
  <meta property="og:image" content="https://sujant-h.github.io/songbook/og-image.jpg" />
  
  <!-- Twitter Card Tags -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Tamil Christian Songs Collection" />
  <meta name="twitter:description" content="A collection of beautiful Tamil Christian songs with translations in English and German" />
  <meta name="twitter:image" content="https://sujant-h.github.io/songbook/og-image.jpg" />
  
  <!-- Canonical URL -->
  <meta name="canonical" href="https://sujant-h.github.io/songbook/" />
  
  <!-- PWA Related -->
  <script src="/src/pwa.ts"></script>
  { pwaInfo && <Fragment set:html={pwaInfo.webManifest.linkTag} /> }
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Tamil:wght@100..900&display=swap" rel="stylesheet" />
  
  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  
  <!-- Structured Data / JSON-LD -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "Tamil Christian Songbook",
      "url": "https://sujant-h.github.io/songbook/",
      "description": "A collection of beautiful Tamil Christian songs with translations in English and German",
      "potentialAction": {
        "@type": "SearchAction",
        "target": "https://sujant-h.github.io/songbook/?search={search_term_string}",
        "query-input": "required name=search_term_string"
      }
    }
  </script>
</head>

  
<body class="bg-gradient-to-b from-indigo-50/50 to-white dark:from-gray-900 dark:to-gray-800 min-h-screen font-tamil dark:text-gray-200 transition-colors duration-200">
  <!-- Outer container -->
  <div class="max-w-6xl mx-auto px-4 py-6 sm:py-8">
    <!-- Header with simplified design -->
    <div class="text-center mb-8 sm:mb-10 relative">
      <h1 class="mb-3 text-2xl sm:text-3xl md:text-4xl font-bold text-indigo-700 dark:text-indigo-400 leading-snug">
        Tamil Christian Songs
      </h1>
      <p class="text-gray-600 dark:text-gray-400 max-w-2xl mx-auto text-sm sm:text-base">
        A collection of beautiful Tamil Christian songs with translations in English and German
      </p>
    </div>

    <!-- Modernized search bar and language dropdown -->
    <div class="search-bar relative mb-8 max-w-3xl mx-auto">
      <div class="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-100 dark:border-gray-700 shadow-sm flex flex-col sm:flex-row items-stretch sm:items-center gap-4 transition-all duration-200">
        <!-- Language Selector -->
        <div class="relative min-w-[120px]">
          <label for="search-lang-select" class="text-xs text-gray-500 dark:text-gray-400 block mb-1 ml-1">Language</label>
          <div class="relative">
            <select 
              id="search-lang-select" 
              class="w-full pl-3 pr-8 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-300 dark:focus:ring-indigo-600 text-gray-700 dark:text-gray-200 appearance-none transition-all duration-200"
            >
              <option value="ta">Tamil</option>
              <option value="en">English</option>
              <option value="de">German</option>
            </select>
            <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500 dark:text-gray-400">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
              </svg>
            </div>
          </div>
        </div>
        
        <!-- Search Input -->
        <div class="flex-grow relative" id="searchContainer">
          <label for="searchInput" class="text-xs text-gray-500 dark:text-gray-400 block mb-1 ml-1">Search</label>
          <div class="relative">
            <!-- Search Icon -->
            <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-indigo-400" fill="none"
                  viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
            </div>
            
            <input
              id="searchInput"
              type="text"
              placeholder="Search by title or lyrics..."
              class="w-full pl-10 pr-10 py-2 border border-gray-200 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-300 dark:focus:ring-indigo-600 text-gray-700 dark:text-gray-200 transition-all duration-200"
            />
            
            <!-- Clear button -->
            <button
              id="clearButton"
              type="button"
              class="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded-md p-1 hidden focus:outline-none transition-colors"
              aria-label="Clear search"
            >
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
 
  
<!-- Polished, elegant song list with enhanced readability -->
<!-- Song list with non-overlapping elements and improved badge system -->
<ul class="grid grid-cols-1 gap-3 sm:gap-6 md:grid-cols-2 lg:grid-cols-3" id="songsList">
  {songs.map((song, index) => (
    <li
      key={song.id}
      data-id={song.id}
      data-index={index}
      data-title={song.title}
      data-text={song.text}
      data-title-en={song.title_en}
      data-text-en={song.text_en}
      data-title-de={song.title_de}
      data-text-de={song.text_de}
      class="song-item bg-white dark:bg-gray-800 rounded-lg border border-gray-100 dark:border-gray-700 hover:shadow-md hover:border-gray-200 dark:hover:border-gray-600 transition-all duration-200 relative mb-3 overflow-hidden group"
    >
  <a href={`https://songbook.sujanth.de/songs/ta/${song.id}`} class="block h-full">
    <!-- Match Badge - Moved to top-right corner with proper spacing -->
        <div class="match-badge hidden absolute top-0 right-0 z-20 text-xs font-medium px-1.5 py-0.5 rounded-md bg-opacity-90 shadow-sm mt-3 mr-3"></div>
        
        <div class="p-3 sm:p-4">
          <!-- Repositioned title section with improved spacing -->
          <div class="flex items-start gap-3">
            <!-- Song ID badge with fixed width -->
            <span class="song-id-badge text-center px-1.5 py-0.5 bg-indigo-200 dark:bg-indigo-800/60 text-indigo-800 dark:text-indigo-200 text-xs font-medium rounded-md flex-shrink-0 w-8 sm:w-10 transition-all duration-300 group-hover:bg-indigo-500 group-hover:text-white transform group-hover:scale-105 group-hover:shadow-sm">
              {song.id}
            </span>
            
            <!-- Title container with improved overflow handling -->
            <div class="flex-1 min-w-0 pt-0.5">
              <h3 class="original-title text-sm sm:text-base font-medium text-gray-900 dark:text-white leading-tight sm:leading-tight tracking-tight break-words">
                {song.title.replace(/^\d+:\s*/, '')}
              </h3>
              <div class="translation-title hidden text-xs text-gray-500 dark:text-gray-400 mt-1 leading-snug"></div>
            </div>
          </div>
          
          <!-- Match context - When search results are found -->
          <div class="match-context hidden mt-3 py-2 px-3 rounded-md border border-gray-100 dark:border-gray-700 bg-gray-50 dark:bg-gray-700/50">
            <p class="text-xs text-gray-700 dark:text-gray-300 leading-relaxed"></p>
          </div>

          <!-- Hidden text snippet container -->
          <div class="relative hidden">
            <div class="text-snippet"></div>
            <div class="absolute bottom-0 left-0 right-0 h-6 bg-gradient-to-t from-white dark:from-gray-800 to-transparent"></div>
          </div>
        </div>
      </a>
    </li>
  ))}    
</ul>

<!-- Enhanced empty state for no search results with clear button -->
<div id="noResultsMessage" class="hidden text-center py-8 bg-white dark:bg-gray-800 rounded-lg border border-gray-100 dark:border-gray-700 p-6 mt-4">
  <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 mx-auto text-gray-400 dark:text-gray-500 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
  <h3 class="text-base font-medium text-gray-700 dark:text-gray-300 mb-1">No songs found</h3>
  <p class="text-gray-500 dark:text-gray-400 text-sm mb-4">Try adjusting your search or language selection</p>
  
  <!-- Clear Search Button -->
  <button 
    id="clearSearchButton" 
    class="inline-flex items-center px-4 py-2 bg-indigo-50 hover:bg-indigo-100 dark:bg-indigo-900/30 dark:hover:bg-indigo-800/50 border border-indigo-200 dark:border-indigo-700 rounded-lg text-indigo-700 dark:text-indigo-300 text-sm font-medium transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-indigo-400 dark:focus:ring-indigo-600"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
    </svg>
    Clear Search
  </button>
</div>

   
    <!-- Pagination (if needed) - updated to match style -->
    <div class="max-w-6xl mx-auto px-4 py-6 flex justify-center">
      <div class="flex gap-2">
        <!-- Pagination can be added here -->
      </div>
    </div>
    
    <!-- Footer with improved styling to match -->
    <footer class="py-6 sm:py-8 px-4 max-w-6xl mx-auto mt-6">
      <div class="bg-white dark:bg-gray-800 rounded-lg border border-gray-100 dark:border-gray-700 shadow-sm p-4 sm:p-6">
        <div class="flex flex-col md:flex-row justify-between items-center gap-4">
          <!-- Theme Toggle -->
          <div class="flex items-center">
            <button 
              id="theme-toggle" 
              class="p-2 sm:p-3 bg-gray-50 dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-300 dark:focus:ring-indigo-500 text-gray-700 dark:text-gray-200 transition-all duration-200 flex items-center gap-2"
              aria-label="Toggle dark mode"
            >
              <!-- Sun icon (shown in dark mode) -->
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-yellow-500 sun-icon hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
              </svg>
              <!-- Moon icon (shown in light mode) -->
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-indigo-600 moon-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
              </svg>
              <span class="text-sm font-medium">Switch Theme</span>
            </button>
          </div>
          
          <!-- Copyright -->
          <div class="text-center text-gray-600 dark:text-gray-400 text-sm">
            <p>Â© 2025 Tamil Christian Songs | All Rights Reserved</p>
          </div>
          
          <!-- Social Links -->
          <div class="flex items-center gap-4">
            <a href="https://github.com/Sujant-h/songbook" class="text-gray-500 hover:text-indigo-600 dark:text-gray-400 dark:hover:text-indigo-400 transition-colors p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700">
              <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                <path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd" />
              </svg>
            </a>
          </div>
        </div>
      </div>
    </footer>
  </div>
  
  <!-- Go to Top Button - updated to match style -->
  <button id="goToTopButton" class="fixed bottom-4 sm:bottom-8 right-4 sm:right-8 bg-indigo-600 hover:bg-indigo-700 dark:bg-indigo-700 dark:hover:bg-indigo-800 text-white rounded-lg shadow-md dark:shadow-black/30 p-3 sm:p-3 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-offset-2 flex items-center justify-center hidden transition-all transform hover:scale-105">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none"
        viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
    </svg>
  </button>


    <script>

      // Add this to your setupEventListeners function

// Clear Search Button on No Results Message
const clearSearchButton = document.getElementById('clearSearchButton');
if (clearSearchButton) {
  clearSearchButton.addEventListener('click', function() {
    // Clear the search input
    searchInput.value = '';
    
    // Hide the clear button in the search input
    clearButton.classList.add('hidden');
    
    // IMPORTANT: First, explicitly make ALL songs visible
    songItems.forEach(item => {
      item.classList.remove('hidden');
      
      // Reset any DOM modifications that might have occurred during search
      
      // 1. Reset match context elements 
      const matchContext = item.querySelector('.match-context');
      if (matchContext) {
        matchContext.classList.add('hidden');
        const matchTextEl = matchContext.querySelector('p');
        if (matchTextEl) {
          matchTextEl.textContent = ''; // Clear any highlighted text
        }
      }
      
      // 2. Reset match badge (both class and inline styles)
      const matchBadge = item.querySelector('.match-badge');
      if (matchBadge) {
        matchBadge.classList.add('hidden');
        matchBadge.className = 'match-badge hidden absolute top-0 right-0 z-20 text-xs font-medium px-1.5 py-0.5 rounded-md bg-opacity-90 shadow-sm mt-3 mr-3';
        // Also reset any inline styles
        matchBadge.style.backgroundColor = '';
        matchBadge.style.color = '';
        matchBadge.textContent = '';
      }
      
      // 3. Reset text snippets
      const textSnippet = item.querySelector('.relative');
      if (textSnippet) {
        textSnippet.classList.add('hidden');
        const snippetText = textSnippet.querySelector('.text-snippet');
        if (snippetText) {
          snippetText.textContent = '';
        }
      }
      
      // 4. Restore original title without highlights
      const originalTitle = item.querySelector('.original-title');
      if (originalTitle) {
        // Get the current language selection
        const selectedLang = langSelect.value;
        let titleField;
        
        if (selectedLang === 'ta') {
          titleField = 'title';
        } else if (selectedLang === 'en') {
          titleField = 'titleEn';
        } else if (selectedLang === 'de') {
          titleField = 'titleDe';
        }
        
        // Explicitly set textContent to remove any HTML/highlights
        const titleText = item.dataset[titleField] || item.dataset.title || '';
        originalTitle.textContent = titleText;
      }
    });
    
    // Hide the no results message
    noResultsMessage.classList.add('hidden');
    
    // Reset the order of songs to their original order
    // This is important as search might have reordered them
    const songItemsArray = Array.from(songItems);
    songItemsArray.sort((a, b) => {
      return parseInt(a.dataset.index) - parseInt(b.dataset.index);
    }).forEach(item => {
      songsList.appendChild(item);
    });
    
    // Ensure the view is updated by triggering a window resize event
    // This can help refresh the layout in some browsers
    window.dispatchEvent(new Event('resize'));
    
    // Focus back on the search input
    searchInput.focus();
  });
}


// Get DOM elements
const searchInput = document.getElementById('searchInput');
const clearButton = document.getElementById('clearButton');
const langSelect = document.getElementById('search-lang-select');
const songsList = document.getElementById('songsList');
const songItems = document.querySelectorAll('.song-item');
const noResultsMessage = document.getElementById('noResultsMessage');
const goToTopButton = document.getElementById('goToTopButton');

// State management
const state = {
  // Update clear button visibility based on search input
  updateClearButtonVisibility() {
    if (searchInput.value.length > 0) {
      clearButton.classList.remove('hidden');
    } else {
      clearButton.classList.add('hidden');
    }
  },

  // Save current state to session storage
  saveState() {
    sessionStorage.setItem('scrollPosition', window.pageYOffset);
    sessionStorage.setItem('searchQuery', searchInput.value);
    sessionStorage.setItem('selectedLang', langSelect.value);
    sessionStorage.setItem('returnedFromSong', 'true');
  },

  // Restore state from session storage
  restoreState() {
    const returnedFromSong = sessionStorage.getItem('returnedFromSong');
    if (returnedFromSong) {
      // Restore search query
      const savedQuery = sessionStorage.getItem('searchQuery');
      if (savedQuery) {
        searchInput.value = savedQuery;
        this.updateClearButtonVisibility();
      }
      
      // Restore language selection
      const savedLang = sessionStorage.getItem('selectedLang');
      if (savedLang && savedLang !== langSelect.value) {
        langSelect.value = savedLang;
        updateSongDisplay();
      }
      
      // Apply the filter to show only matching results
      // This must be called after restoring search query and language
      if (savedQuery && savedQuery.trim() !== '') {
        filterSongs();
        
        // Make sure text matches are shown
        setTimeout(() => {
          songItems.forEach(item => {
            const searchTerm = savedQuery.toLowerCase().trim();
            let textField;
            
            // Get the appropriate field based on language
            if (langSelect.value === 'ta') {
              textField = 'text';
            } else if (langSelect.value === 'en') {
              textField = 'textEn';
            } else if (langSelect.value === 'de') {
              textField = 'textDe';
            }
            
            // Check if this item has a text match
            const text = item.dataset[textField] ? 
              item.dataset[textField].toLowerCase() : 
              item.dataset.text.toLowerCase();
            
            // If there's a text match, show the context
            if (text.includes(searchTerm)) {
              const matchContext = item.querySelector('.match-context');
              if (matchContext) {
                const rawText = item.dataset[textField] || item.dataset.text || '';
                const context = findMatchContext(rawText, searchTerm);
                matchContext.innerHTML = highlightMatches(context, searchTerm);
                matchContext.classList.remove('hidden');
              }
            }
          });
        }, 50);
      }
      
      // Restore scroll position
      const savedPosition = sessionStorage.getItem('scrollPosition');
      if (savedPosition) {
        // Use setTimeout to ensure the scroll happens after the DOM is fully updated
        setTimeout(() => {
          window.scrollTo(0, parseInt(savedPosition));
        }, 100);
      }
      
      // Clear session storage
      this.clearState();
    }
  },

  // Clear state from session storage
  clearState() {
    sessionStorage.removeItem('returnedFromSong');
    sessionStorage.removeItem('scrollPosition');
    sessionStorage.removeItem('searchQuery');
    sessionStorage.removeItem('selectedLang');
  }
};

// Function to highlight text matches in a string
function highlightMatches(text, searchTerm) {
  if (!searchTerm || searchTerm.trim() === '' || !text) return text;
  
  const regex = new RegExp(`(${searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')})`, 'gi');
  return text.replace(regex, '<mark class="bg-yellow-200 text-gray-800 dark:bg-yellow-500/60 dark:text-gray-100 px-1 py-0.5 rounded-sm font-medium">$1</mark>');
}

// Function to find the context around a match
function findMatchContext(text, searchTerm, contextLength = 50) {
  if (!searchTerm || searchTerm.trim() === '' || !text) return '';
  
  searchTerm = searchTerm.toLowerCase();
  const index = text.toLowerCase().indexOf(searchTerm);
  
  if (index === -1) return '';
  
  const start = Math.max(0, index - contextLength);
  const end = Math.min(text.length, index + searchTerm.length + contextLength);
  
  // Add ellipsis if we're not showing from the beginning or to the end
  const prefix = start > 0 ? '...' : '';
  const suffix = end < text.length ? '...' : '';
  
  return prefix + text.substring(start, end) + suffix;
}

// Reorder songs to show title matches first, then text matches
function reorderSongsByMatchPriority() {
  const songItemsArray = Array.from(songItems);
  const searchTerm = searchInput.value.toLowerCase().trim();
  
  if (searchTerm === '') return;
  
  // Sort visible songs by match type
  songItemsArray
    .filter(item => !item.classList.contains('hidden'))
    .sort((a, b) => {
      const aBadge = a.querySelector('.match-badge').textContent || '';
      const bBadge = b.querySelector('.match-badge').textContent || '';
      
      // Assign priority: ID = 3, Title = 2, Text = 1, Word matches = 0
      let aPriority = 0;
      let bPriority = 0;
      
      if (aBadge.includes('ID')) aPriority = 3;
      else if (aBadge.includes('Title')) aPriority = 2;
      else if (aBadge === 'Text') aPriority = 1;
      // Word matches get priority 0
      
      if (bBadge.includes('ID')) bPriority = 3;
      else if (bBadge.includes('Title')) bPriority = 2;
      else if (bBadge === 'Text') bPriority = 1;
      // Word matches get priority 0
      
      // If both are word matches (all words match), sort by ID
      if (aPriority === 0 && bPriority === 0) {
        // Sort by song ID as a tiebreaker
        const aId = parseInt(a.dataset.id);
        const bId = parseInt(b.dataset.id);
        
        return aId - bId;
      }
      
      return bPriority - aPriority;
    })
    .forEach(item => {
      songsList.appendChild(item);
    });
}
// Update the filterSongs function to handle badge classes properly
// Enhanced filterSongs function that checks individual words when no results are found
// Enhanced filterSongs function that checks individual words when no results are found
function filterSongs() {
  const searchTerm = searchInput.value.toLowerCase().trim();
  const selectedLang = langSelect.value;
  let visibleCount = 0;
  
  // First, hide all text snippets completely
  document.querySelectorAll('.song-item .relative').forEach(snippet => {
    snippet.classList.add('hidden');
  });
  
  // Reset match badges - hide all of them first and reset classes
  document.querySelectorAll('.match-badge').forEach(badge => {
    badge.classList.add('hidden');
    badge.className = 'match-badge hidden absolute top-0 right-0 z-20 text-xs font-medium px-1.5 py-0.5 rounded-md bg-opacity-90 shadow-sm mt-3 mr-3';
  });
  
  // Perform initial search with the full search term
  songItems.forEach(item => {
    let titleField, textField;
    
    // Select the appropriate fields based on language
    if (selectedLang === 'ta') {
      titleField = 'title';
      textField = 'text';
    } else if (selectedLang === 'en') {
      titleField = 'titleEn';
      textField = 'textEn';
    } else if (selectedLang === 'de') {
      titleField = 'titleDe';
      textField = 'textDe';
    }
    
    // Get the appropriate data for the selected language
    // Fall back to Tamil if translation is missing
    const title = item.dataset[titleField] ? 
      item.dataset[titleField].toLowerCase() : 
      item.dataset.title.toLowerCase();
      
    const text = item.dataset[textField] ? 
      item.dataset[textField].toLowerCase() : 
      item.dataset.text.toLowerCase();
    
    // Get song ID and compare as a string
    const songId = item.dataset.id;
    
    const originalTitle = item.querySelector('.original-title');
    const matchBadge = item.querySelector('.match-badge');
    const matchContext = item.querySelector('.match-context');
    const matchTextEl = matchContext ? matchContext.querySelector('p') : null;
    
    // Separate check for each type of match
    const idHit = searchTerm !== '' && songId.toLowerCase().includes(searchTerm);
    const titleHit = searchTerm !== '' && title.includes(searchTerm);
    const textHit = searchTerm !== '' && text.includes(searchTerm);

    // Mark as visible if any hit is found or if no search term
    if (idHit || titleHit || textHit || searchTerm === '') {
      item.classList.remove('hidden');
      visibleCount++;
      
      // Handle search results
      if (searchTerm !== '') {
        if (idHit || titleHit || textHit) {
          // Show and style the match badge appropriately based on match type
          matchBadge.classList.remove('hidden');
          
          // If ID hit, show as an ID match (purple badge)
          if (idHit) {
            matchBadge.style.backgroundColor = '#f3e8ff'; // purple-100
            matchBadge.style.color = '#6b21a8';          // purple-800
            matchBadge.textContent = 'ID';
          }
          // If title hit (but not ID hit), show as a title match (green badge)
          else if (titleHit) {
            matchBadge.style.backgroundColor = '#dcfce7'; // green-100
            matchBadge.style.color = '#166534';          // green-800
            matchBadge.textContent = 'Title';
          } 
          // If only text hit, show as a text match (blue badge)
          else {
            matchBadge.style.backgroundColor = '#dbeafe'; // blue-100
            matchBadge.style.color = '#1e40af';          // blue-800
            matchBadge.textContent = 'Text';
          }
        } else {
          // No matches - ensure badge is hidden
          matchBadge.classList.add('hidden');
        }
        
        // Show match context for text hits
        if (textHit && !idHit && !titleHit && matchTextEl) {
          const rawText = item.dataset[textField] || item.dataset.text || '';
          const context = findMatchContext(rawText, searchTerm);
          matchTextEl.innerHTML = highlightMatches(context, searchTerm);
          matchContext.classList.remove('hidden');
        } else if (matchContext) {
          matchContext.classList.add('hidden');
        }
        
        // Highlight title if there's a title match
        if (titleHit) {
          const rawTitle = item.dataset[titleField] || item.dataset.title || '';
          originalTitle.innerHTML = highlightMatches(rawTitle, searchTerm);
        } 
        // For ID matches, don't modify the title display - just use the original title
        else {
          // Use plain text for title when no match
          originalTitle.textContent = item.dataset[titleField] || item.dataset.title || '';
        }
      } else {
        // When no search term, make sure badges and contexts are hidden
        matchBadge.classList.add('hidden');
        if (matchContext) matchContext.classList.add('hidden');
        
        // Restore original title as plain text
        originalTitle.textContent = item.dataset[titleField] || item.dataset.title || '';
      }
    } else {
      item.classList.add('hidden');
    }
  });
  
  // If no songs are visible and we have a search term with multiple words, try searching for songs that contain ALL individual words
  if (visibleCount === 0 && searchTerm !== '') {
    // Split the search term into individual words
    const searchWords = searchTerm.split(/\s+/).filter(word => word.length > 1);
    
    // Only proceed if we have multiple words to search
    if (searchWords.length > 0) {
      // Create a status message for the no results panel
      const statusMessageEl = document.createElement('div');
      statusMessageEl.className = 'text-gray-600 dark:text-gray-400 text-sm mt-2';
      statusMessageEl.innerHTML = 'No exact phrase matches found. Showing results containing all words:';
      
      // Add a list of the words we're searching for
      const wordsList = document.createElement('div');
      wordsList.className = 'flex flex-wrap gap-2 mt-2';
      searchWords.forEach(word => {
        const wordBadge = document.createElement('span');
        wordBadge.className = 'px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded-md text-xs font-medium';
        wordBadge.textContent = word;
        wordsList.appendChild(wordBadge);
      });
      
      // Check individual words
      songItems.forEach(item => {
        let titleField, textField;
        
        // Select the appropriate fields based on language
        if (selectedLang === 'ta') {
          titleField = 'title';
          textField = 'text';
        } else if (selectedLang === 'en') {
          titleField = 'titleEn';
          textField = 'textEn';
        } else if (selectedLang === 'de') {
          titleField = 'titleDe';
          textField = 'textDe';
        }
        
        // Get text content
        const title = item.dataset[titleField] ? 
          item.dataset[titleField].toLowerCase() : 
          item.dataset.title.toLowerCase();
          
        const text = item.dataset[textField] ? 
          item.dataset[textField].toLowerCase() : 
          item.dataset.text.toLowerCase();
        
        const songId = item.dataset.id;
        
        const originalTitle = item.querySelector('.original-title');
        const matchBadge = item.querySelector('.match-badge');
        const matchContext = item.querySelector('.match-context');
        const matchTextEl = matchContext ? matchContext.querySelector('p') : null;
        
        // Check if ALL individual words match (must be in the text)
        const allWordsMatch = searchWords.every(word => text.includes(word));
        
        if (allWordsMatch) {
          // Mark as visible
          item.classList.remove('hidden');
          visibleCount++;
          
          // Show match badge
          matchBadge.classList.remove('hidden');
          matchBadge.style.backgroundColor = '#dbeafe'; // blue-100
          matchBadge.style.color = '#1e40af';          // blue-800
          matchBadge.textContent = `All ${searchWords.length} words`;
          
          // Find and highlight the first matching word in the text
          if (matchTextEl) {
            let context = '';
            for (const word of matchingWords) {
              if (text.includes(word)) {
                const rawText = item.dataset[textField] || item.dataset.text || '';
                context = findMatchContext(rawText, word);
                if (context) {
                  // Highlight all matching words in the context
                  let highlightedContext = context;
                  for (const matchWord of matchingWords) {
                    highlightedContext = highlightMatches(highlightedContext, matchWord);
                  }
                  matchTextEl.innerHTML = highlightedContext;
                  matchContext.classList.remove('hidden');
                  break;
                }
              }
            }
            
            // If no context found in text, try title
            if (!context && title) {
              for (const word of matchingWords) {
                if (title.includes(word)) {
                  const rawTitle = item.dataset[titleField] || item.dataset.title || '';
                  // Highlight all matching words in the title
                  let highlightedTitle = rawTitle;
                  for (const matchWord of matchingWords) {
                    highlightedTitle = highlightMatches(highlightedTitle, matchWord);
                  }
                  originalTitle.innerHTML = highlightedTitle;
                  break;
                }
              }
            }
          }
        }
      });
      
      // If we now have results, modify the no results message
      if (visibleCount > 0) {
        // Clear existing no results message content
        while (noResultsMessage.firstChild) {
          noResultsMessage.removeChild(noResultsMessage.firstChild);
        }
        
        // Create new elements for the modified message
        const icon = document.createElement('svg');
        icon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 mx-auto text-yellow-400 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>';
        
        const title = document.createElement('h3');
        title.className = 'text-base font-medium text-gray-700 dark:text-gray-300 mb-1';
        title.textContent = 'No exact phrase matches found';
        
        const subtitle = document.createElement('p');
        subtitle.className = 'text-gray-500 dark:text-gray-400 text-sm mb-3';
        subtitle.textContent = `Showing ${visibleCount} results containing all search words`;
        
        // Add button for clear search
        const clearButton = document.createElement('button');
        clearButton.id = 'clearPartialSearchButton';
        clearButton.className = 'inline-flex items-center px-4 py-2 bg-indigo-50 hover:bg-indigo-100 dark:bg-indigo-900/30 dark:hover:bg-indigo-800/50 border border-indigo-200 dark:border-indigo-700 rounded-lg text-indigo-700 dark:text-indigo-300 text-sm font-medium transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-indigo-400 dark:focus:ring-indigo-600';
        clearButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>Clear Search';
        
        // Add elements to the no results message
        noResultsMessage.appendChild(icon);
        noResultsMessage.appendChild(title);
        noResultsMessage.appendChild(subtitle);
        noResultsMessage.appendChild(document.createElement('div')).appendChild(wordsList);
        noResultsMessage.appendChild(document.createElement('div')).appendChild(clearButton);
        
        // Add event listener to the new clear button
        clearButton.addEventListener('click', function() {
          searchInput.value = '';
          clearButton.classList.add('hidden');
          filterSongs();
        });
        
        // Show the modified message
        noResultsMessage.classList.remove('hidden');
      }
    }
  }
  
  // Show/hide no results message
  noResultsMessage.classList.toggle('hidden', visibleCount > 0);
  
  // Reorder songs to prioritize ID, title, and then text matches
  if (searchTerm !== '' && visibleCount > 0) {
    reorderSongsByMatchPriority();
  }
}




// Update song display based on selected language
// Update song display based on selected language
function updateSongDisplay() {
  const selectedLang = langSelect.value;
  // Update this line to use the full URL
  const baseUrl = 'https://songbook.sujanth.de';
  const searchTerm = searchInput.value.trim();
  
  // Always hide text snippets
  document.querySelectorAll('.song-item .relative').forEach(snippet => {
    snippet.classList.add('hidden');
  });
  
  songItems.forEach(item => {
    const originalTitle = item.querySelector('.original-title');
    const translationTitle = item.querySelector('.translation-title');
    const matchContext = item.querySelector('.match-context');
    const link = item.querySelector('a');
    
    const songId = item.dataset.id;
    const originalTitleText = item.dataset.title;
    
    let displayTitle;
    
    // Set the appropriate titles based on language
    if (selectedLang === 'ta') {
      displayTitle = originalTitleText;
      translationTitle.classList.add('hidden');
      link.href = `${baseUrl}/songs/ta/${songId}`;
    } else if (selectedLang === 'en') {
      displayTitle = item.dataset.titleEn || originalTitleText;
      
      if (item.dataset.title && displayTitle !== originalTitleText) {
        translationTitle.textContent = ` ${originalTitleText}`;
        translationTitle.classList.remove('hidden');
      } else {
        translationTitle.classList.add('hidden');
      }
      
      link.href = `${baseUrl}/songs/en/${songId}`;
    } else if (selectedLang === 'de') {
      displayTitle = item.dataset.titleDe || originalTitleText;
      
      if (item.dataset.title && displayTitle !== originalTitleText) {
        translationTitle.textContent = `${originalTitleText}`;
        translationTitle.classList.remove('hidden');
      } else {
        translationTitle.classList.add('hidden');
      }
      
      link.href = `${baseUrl}/songs/de/${songId}`;
    }
    
    // Update text content (no highlights if not searching)
    if (searchTerm === '') {
      originalTitle.textContent = displayTitle;
      
      // Ensure match context is hidden
      if (matchContext) {
        matchContext.classList.add('hidden');
      }
    }
  });
  
  // When changing language, re-apply any active search filters
  if (searchInput.value.trim() !== '') {
    filterSongs();
  }
}

// Event Listeners
function setupEventListeners() {
  // Search input event
  searchInput.addEventListener('input', function() {
    state.updateClearButtonVisibility();
    filterSongs();
  });
  
// Enhanced clear button click handler with explicit DOM manipulation
clearButton.addEventListener('click', function() {
  // Clear the search input
  searchInput.value = '';
  
  // Hide the clear button
  clearButton.classList.add('hidden');
  
  // IMPORTANT: First, explicitly make ALL songs visible
  songItems.forEach(item => {
    item.classList.remove('hidden');
    
    // Reset any DOM modifications that might have occurred during search
    
    // 1. Reset match context elements 
    const matchContext = item.querySelector('.match-context');
    if (matchContext) {
      matchContext.classList.add('hidden');
      const matchTextEl = matchContext.querySelector('p');
      if (matchTextEl) {
        matchTextEl.textContent = ''; // Clear any highlighted text
      }
    }
    
    // 2. Reset match badge (both class and inline styles)
    const matchBadge = item.querySelector('.match-badge');
    if (matchBadge) {
      matchBadge.classList.add('hidden');
      matchBadge.className = 'match-badge hidden absolute top-1 left-1 z-20 text-xs font-medium px-1.5 py-0.5 sm:px-2 sm:py-1 rounded-md bg-opacity-90 shadow-sm';
      // Also reset any inline styles
      matchBadge.style.backgroundColor = '';
      matchBadge.style.color = '';
      matchBadge.textContent = '';
    }
    
    // 3. Reset text snippets
    const textSnippet = item.querySelector('.relative');
    if (textSnippet) {
      textSnippet.classList.add('hidden');
      const snippetText = textSnippet.querySelector('.text-snippet');
      if (snippetText) {
        snippetText.textContent = '';
      }
    }
    
    // 4. Restore original title without highlights
    const originalTitle = item.querySelector('.original-title');
    if (originalTitle) {
      // Get the current language selection
      const selectedLang = langSelect.value;
      let titleField;
      
      if (selectedLang === 'ta') {
        titleField = 'title';
      } else if (selectedLang === 'en') {
        titleField = 'titleEn';
      } else if (selectedLang === 'de') {
        titleField = 'titleDe';
      }
      
      // Explicitly set textContent to remove any HTML/highlights
      const titleText = item.dataset[titleField] || item.dataset.title || '';
      originalTitle.textContent = titleText;
    }
  });
  
  // Hide the no results message
  noResultsMessage.classList.add('hidden');
  
  // Reset the order of songs to their original order
  // This is important as search might have reordered them
  const songItemsArray = Array.from(songItems);
  songItemsArray.sort((a, b) => {
    return parseInt(a.dataset.index) - parseInt(b.dataset.index);
  }).forEach(item => {
    songsList.appendChild(item);
  });
  
  // Ensure the view is updated by triggering a window resize event
  // This can help refresh the layout in some browsers
  window.dispatchEvent(new Event('resize'));
  
  // Focus back on the search input
  searchInput.focus();
});

  // Helper function to restore original titles
  function restoreOriginalTitles() {
    const selectedLang = langSelect.value;
    
    songItems.forEach(item => {
      let titleField;
      
      // Select the appropriate field based on language
      if (selectedLang === 'ta') {
        titleField = 'title';
      } else if (selectedLang === 'en') {
        titleField = 'titleEn';
      } else if (selectedLang === 'de') {
        titleField = 'titleDe';
      }
      
      const originalTitle = item.querySelector('.original-title');
      if (originalTitle) {
        // Use the plain text content without any HTML/highlights
        originalTitle.textContent = item.dataset[titleField] || item.dataset.title || '';
      }
    });
  }
  
  // Language change event
  langSelect.addEventListener('change', function() {
    updateSongDisplay();
    
    // Hide all text-related elements when changing language (if not searching)
    if (searchInput.value.trim() === '') {
      document.querySelectorAll('.match-context').forEach(context => {
        context.classList.add('hidden');
      });
      
      document.querySelectorAll('.match-badge').forEach(badge => {
        badge.classList.add('hidden');
      });
      
      document.querySelectorAll('.song-item .relative').forEach(snippet => {
        snippet.classList.add('hidden');
      });
    } else {
      // Reapply search if there's an active search term
      filterSongs();
    }
  });
  
  // Scroll event for "Go to Top" button
  window.addEventListener('scroll', function() {
    goToTopButton.classList.toggle('hidden', window.pageYOffset <= 300);
  });
  
  // Go to Top button click
  goToTopButton.addEventListener('click', function() {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  });
  
  // Save state when navigating to a song
  document.querySelectorAll('.song-item a').forEach(link => {
    link.addEventListener('click', function(e) {
      state.saveState();
    });
  });
  
  // Back/forward navigation handling
  window.addEventListener('popstate', function() {
    state.updateClearButtonVisibility();
    filterSongs();
  });
}

// Initialize
function init() {
  // Set up all event listeners
  setupEventListeners();
  
  // Initialize song display
  updateSongDisplay();
  
  // Restore state if returning from a song
  state.restoreState();
  
  // Update clear button visibility (handles page reload cases)
  state.updateClearButtonVisibility();
  
  // Make sure no song text is shown on initial load
  document.querySelectorAll('.match-context').forEach(context => {
    context.classList.add('hidden');
  });
  
  // Hide all text snippets at startup
  document.querySelectorAll('.song-item .relative').forEach(snippet => {
    snippet.classList.add('hidden');
  });
}

// Run initialization when DOM is loaded
document.addEventListener('DOMContentLoaded', init);
    </script>
  </body>
</html>
