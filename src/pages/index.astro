---
import songs from '../data/data_cleaned.json';
import '../styles/global.css';
import '../styles/index.css';
import { pwaInfo } from 'virtual:pwa-info';

export interface Props {
  title: string;
}

const { title } = Astro.props as Props;
---

<!DOCTYPE html>
<html lang="ta">
  <!-- Blocking script in the head to prevent flash -->
  <script is:inline>
    // Check theme preference and apply it immediately
    const savedTheme = localStorage.getItem('theme');
    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (savedTheme === 'dark' || (!savedTheme && systemPrefersDark)) {
      document.documentElement.classList.add('dark');
    }

    // theme-toggle.js
document.addEventListener('DOMContentLoaded', () => {
    // Check for saved theme preference or use the system preference
    const savedTheme = localStorage.getItem('theme');
    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    // Apply the theme based on saved preference or system preference
    if (savedTheme === 'dark' || (!savedTheme && systemPrefersDark)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
    
    // Update the toggle button's state
    updateToggleState();
    
    // Add event listener to the theme toggle button
    const themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
      themeToggle.addEventListener('click', () => {
        // Toggle the dark class on the html element
        document.documentElement.classList.toggle('dark');
        
        // Save the current preference to localStorage
        const isDark = document.documentElement.classList.contains('dark');
        localStorage.setItem('theme', isDark ? 'dark' : 'light');
        
        // Update the toggle button's state
        updateToggleState();
      });
    }
  });
  
  // Update the toggle button to reflect the current theme
  function updateToggleState() {
    const themeToggle = document.getElementById('theme-toggle');
    const isDark = document.documentElement.classList.contains('dark');
    
    if (themeToggle) {
      const sunIcon = themeToggle.querySelector('.sun-icon');
      const moonIcon = themeToggle.querySelector('.moon-icon');
      
      if (sunIcon && moonIcon) {
        if (isDark) {
          sunIcon.classList.remove('hidden');
          moonIcon.classList.add('hidden');
        } else {
          sunIcon.classList.add('hidden');
          moonIcon.classList.remove('hidden');
        }
      }
    }
  }
  </script>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <link rel="apple-touch-icon" href="/pwa-192x192.png" />
    <link rel="mask-icon" href="/favicon.svg" color="#FFFFFF" />
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="theme-color" content="#ffffff" />
    <title>{title}</title>
    <meta name="description" content={title} />

    <script src="/src/pwa.ts"></script>
    { pwaInfo && <Fragment set:html={pwaInfo.webManifest.linkTag} /> }
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Tamil:wght@100..900&display=swap" rel="stylesheet" />
    <!-- Include Material Icons from Google Fonts -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    
    <!-- Regular theme toggle script for interactive functionality -->
  </head>

  
<body class="bg-gradient-to-b from-indigo-50 to-white dark:from-gray-900 dark:to-gray-800 min-h-screen font-tamil dark:text-gray-200 transition-colors duration-200">
    <!-- Outer container -->
    <div class="max-w-6xl mx-auto px-4 py-8">
      <!-- Header with title -->
      <div class="text-center mb-10">
        <h1 class="mt-2 mb-4 lg:mt-8 text-3xl md:text-4xl font-extrabold text-indigo-800 dark:text-indigo-400 leading-snug">
          Tamil Christian Songs
        </h1>
        <p class="text-gray-600 dark:text-gray-400 max-w-2xl mx-auto">
          A collection of beautiful Tamil Christian songs with translations in English and German
        </p>
      </div>
  
      <!-- Search bar, language dropdown, and theme toggle -->
      <!-- Update the existing search bar container with transition classes -->
<div class="search-bar relative mb-10 max-w-3xl mx-auto">
  <div class="bg-white dark:bg-gray-800 p-3 rounded-xl shadow-md dark:shadow-gray-900/30 flex items-center gap-4 transition-all duration-300 ease-in-out">
    <!-- Language Selector -->
    <div class="relative">
      <label for="search-lang-select" class="text-xs text-gray-500 dark:text-gray-400 block mb-1 ml-1">Language</label>
      <div class="relative">
        <select 
          id="search-lang-select" 
          class="pl-3 pr-8 py-2 bg-indigo-50 dark:bg-gray-700 border border-indigo-100 dark:border-gray-600 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-300 dark:focus:ring-indigo-600 text-gray-700 dark:text-gray-200 appearance-none transition-all duration-200"
        >
          <option value="ta">Tamil</option>
          <option value="en">English</option>
          <option value="de">German</option>
        </select>
        <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500 dark:text-gray-400">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </div>
      </div>
    </div>
    
    <!-- Search Input -->
    <div class="flex-grow relative transition-all duration-300 ease-in-out transform-gpu" id="searchContainer">
      <label for="searchInput" class="text-xs text-gray-500 dark:text-gray-400 block mb-1 ml-1">Search</label>
      <div class="relative">
        <!-- Search Icon -->
        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-indigo-400" fill="none"
               viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </div>
        
        <input
          id="searchInput"
          type="text"
          placeholder="Search by title or lyrics..."
          class="w-full pl-10 pr-10 py-2 border border-indigo-100 dark:border-gray-600 bg-indigo-50 dark:bg-gray-700 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-300 dark:focus:ring-indigo-600 text-gray-700 dark:text-gray-200 transition-all duration-200"
        />
        
        <!-- Clear button -->
        <button
          id="clearButton"
          type="button"
          class="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded-md p-1 hidden focus:outline-none transition-colors"
          aria-label="Clear search"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
    </div>

    <!-- Theme Toggle Button -->
    <div class="relative transition-all duration-300 ease-in-out transform-gpu" id="themeToggleContainer">
      <label class="text-xs text-gray-500 dark:text-gray-400 block mb-1 ml-1">Theme</label>
      <button 
        id="theme-toggle" 
        class="p-2 bg-indigo-50 dark:bg-gray-700 border border-indigo-100 dark:border-gray-600 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-300 dark:focus:ring-indigo-600 text-gray-700 dark:text-gray-200 transition-all duration-200"
        aria-label="Toggle dark mode"
      >
        <!-- Sun icon (shown in dark mode) -->
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-yellow-500 sun-icon hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
        </svg>
        <!-- Moon icon (shown in light mode) -->
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-indigo-600 moon-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
        </svg>
      </button>
    </div>
  </div>
</div>
 
  
<!-- Song list with fixed badge and proper centering -->
<ul class="grid grid-cols-1 gap-2 sm:gap-6 md:grid-cols-2 lg:grid-cols-3" id="songsList">
  {songs.map((song, index) => (
    <li
      key={song.id}
      data-id={song.id}
      data-index={index}
      data-title={song.title}
      data-text={song.text}
      data-title-en={song.title_en}
      data-text-en={song.text_en}
      data-title-de={song.title_de}
      data-text-de={song.text_de}
      class="song-item w-full rounded-md sm:rounded-xl shadow-md hover:shadow-xl transition-all duration-300 overflow-hidden bg-white dark:bg-gray-800 group relative"
    >
      <a href={`${import.meta.env.BASE_URL}/songs/ta/${song.id}`} class="block h-full">
        <!-- Card header with music icon - smaller on mobile -->
        <div class="bg-indigo-600 dark:bg-indigo-700 h-1 sm:h-2 group-hover:h-3 sm:group-hover:h-4 transition-all duration-300"></div>
        
        <div class="p-2 sm:p-4 md:p-5">
          <!-- Match Badge positioned at the top-left of the box to avoid title overlap -->
          <!-- Match Badge with larger text -->
          <div class="match-badge hidden absolute top-1 left-1 z-20 text-xs sm:text-xs font-medium px-1.5 py-0.5 sm:px-2 sm:py-1 rounded-md bg-opacity-90 shadow-sm"></div>          
          <!-- Title section with larger font sizes for mobile -->
<div class="title-container mt-3 sm:mt-0 mb-2 sm:mb-3">
  <div class="flex items-center gap-1 sm:gap-2">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-4 sm:w-4 md:h-5 md:w-5 text-indigo-600 dark:text-indigo-400 opacity-75 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
    </svg>
    <div class="flex flex-col justify-center max-w-full">
      <div class="original-title text-sm sm:text-sm md:text-base font-medium text-gray-800 dark:text-gray-200 group-hover:text-indigo-700 dark:group-hover:text-indigo-400 transition-colors break-words">
        {song.title}
      </div>
      <div class="translation-title hidden text-xs sm:text-xs md:text-sm text-gray-500 dark:text-gray-400 mt-0.5 break-words"></div>
    </div>
  </div>
</div>
          
<!-- Text match context with larger text -->
<div class="match-context hidden mt-2 sm:mt-3 mb-2 sm:mb-3 py-2 px-3 sm:py-2.5 sm:px-4 rounded-md border border-indigo-100 dark:border-gray-700 bg-indigo-50/70 dark:bg-gray-700/70 shadow-sm">
  <p class="text-xs sm:text-xs md:text-sm text-gray-700 dark:text-gray-300 leading-relaxed"></p>
</div>
          
          <!-- Text snippet - hidden -->
          <div class="relative hidden">
            <div class="text-snippet"></div>
            <div class="absolute bottom-0 left-0 right-0 h-6 bg-gradient-to-t from-white dark:from-gray-800 to-transparent"></div>
          </div>
          
          <!-- Card footer - visible only on tablet and larger screens -->
          <div class="hidden sm:flex mt-2 sm:mt-3 pt-1 sm:pt-2 border-t border-gray-100 dark:border-gray-700 justify-between items-center">
            <span class="text-xs text-gray-400 dark:text-gray-500">#{index + 1}</span>
            <span class="text-indigo-500 dark:text-indigo-400 text-xs sm:text-sm font-medium flex items-center gap-1 group-hover:translate-x-1 transition-transform">
              View
              <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 sm:h-4 sm:w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </span>
          </div>
        </div>
      </a>
    </li>
  ))}    
</ul>
      
      <!-- Empty state for no search results -->
      <div id="noResultsMessage" class="hidden text-center py-10">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto text-gray-400 dark:text-gray-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <h3 class="text-lg font-medium text-gray-700 dark:text-gray-300 mb-1">No songs found</h3>
        <p class="text-gray-500 dark:text-gray-400">Try adjusting your search or language selection</p>
      </div>
    </div>
  
    <!-- Pagination (if needed) -->
    <div class="max-w-6xl mx-auto px-4 py-6 flex justify-center">
      <div class="flex gap-2">
        <!-- Pagination can be added here -->
      </div>
    </div>
  
    <!-- Footer -->
    <footer class="py-6 text-center text-gray-500 dark:text-gray-400 text-sm">
      <p>Â© 2025 Tamil Christian Songbook</p>
    </footer>
  
    <!-- Go to Top Button with improved styling -->
    <button id="goToTopButton" class="fixed bottom-6 right-6 bg-indigo-600 hover:bg-indigo-700 dark:bg-indigo-700 dark:hover:bg-indigo-800 text-white rounded-full shadow-lg dark:shadow-black/30 p-3 focus:outline-none flex items-center justify-center hidden transition-all transform hover:scale-105">
      <span class="hidden sm:flex items-center justify-center gap-2">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none"
             viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
        </svg>
        <span>Go to Top</span>
      </span>
      <span class="sm:hidden flex items-center justify-center">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none"
             viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
        </svg>
      </span>
    </button>



    <script>
// Enhanced script.js with fixed search bar expansion/shrinking

// Get the necessary DOM elements
const searchInput = document.getElementById('searchInput');
const clearButton = document.getElementById('clearButton');
const langSelect = document.getElementById('search-lang-select');
const songsList = document.getElementById('songsList');
const songItems = document.querySelectorAll('.song-item');
const noResultsMessage = document.getElementById('noResultsMessage');
const goToTopButton = document.getElementById('goToTopButton');

// Search expansion elements - with null checks
let searchContainer = null;
let themeToggleContainer = null;
let searchBarContainer = null;

// Function to handle search field focus and blur
function setupSearchExpansion() {
  // Find the search elements
  searchContainer = document.getElementById('searchContainer');
  themeToggleContainer = document.getElementById('themeToggleContainer');
  searchBarContainer = document.querySelector('.search-bar .bg-white');

  // Check if all necessary elements exist
  if (!searchContainer || !themeToggleContainer || !searchInput) {
    console.warn('Search expansion elements not found. Skipping setup.');
    return;
  }

  // Store the original width/flex classes
  let originalSearchClasses = [];
  let originalToggleClasses = [];
  
  // Save the original classes immediately
  Array.from(searchContainer.classList).forEach(className => {
    if (className.includes('flex-') || className.includes('w-')) {
      originalSearchClasses.push(className);
    }
  });
  
  Array.from(themeToggleContainer.classList).forEach(className => {
    originalToggleClasses.push(className);
  });
  
  // Add transition classes if they don't already exist
  if (!searchContainer.classList.contains('transition-all')) {
    searchContainer.classList.add('transition-all', 'duration-300', 'ease-in-out');
  }
  if (!themeToggleContainer.classList.contains('transition-all')) {
    themeToggleContainer.classList.add('transition-all', 'duration-300', 'ease-in-out');
  }
  
  // When search input is focused
  searchInput.addEventListener('focus', function() {
    expandSearchBar();
  });
  
  // When search input loses focus
  searchInput.addEventListener('blur', function() {
    // Only restore the original layout if there's no active search
    if (searchInput.value.trim() === '') {
      setTimeout(() => {
        shrinkSearchBar();
      }, 150);
    }
  });
  
  // When search is cleared, restore the original layout
  if (clearButton) {
    clearButton.addEventListener('click', function() {
      // Additional handling for search clearing - restore original layout
      setTimeout(function() {
        shrinkSearchBar();
      }, 300); // Short delay to allow animation to complete
    });
  }
  
  // Helper function to expand the search bar
  function expandSearchBar() {
    // Make sure elements exist
    if (!searchContainer || !themeToggleContainer) return;
    
    // Add a scale effect while expanding
    searchContainer.classList.add('flex-grow', 'z-10');
    
    // Hide theme toggle with Tailwind classes
    themeToggleContainer.classList.add('opacity-0');
    themeToggleContainer.classList.add('w-0');
    themeToggleContainer.classList.add('overflow-hidden');
    themeToggleContainer.classList.add('pointer-events-none');
    
    // Add a style for larger screens
    if (window.innerWidth >= 640) { // sm breakpoint
      searchContainer.classList.add('max-w-xl');
    }
  }
  
  // Helper function to shrink the search bar
  function shrinkSearchBar() {
    // Make sure elements exist
    if (!searchContainer || !themeToggleContainer) return;
    
    // Don't shrink if there's text in the search field
    if (searchInput.value.trim() !== '') return;
    
    // Remove expansion classes
    searchContainer.classList.remove('flex-grow', 'z-10', 'max-w-xl');
    
    // Re-apply original classes if they were removed
    originalSearchClasses.forEach(className => {
      if (!searchContainer.classList.contains(className)) {
        searchContainer.classList.add(className);
      }
    });
    
    // Show theme toggle with animation
    themeToggleContainer.classList.remove('w-0');
    themeToggleContainer.classList.remove('overflow-hidden');
    themeToggleContainer.classList.remove('pointer-events-none');
    
    // After small delay, restore opacity
    setTimeout(() => {
      themeToggleContainer.classList.remove('opacity-0');
    }, 50);
  }
}

// State management
const state = {
  // Update clear button visibility based on search input
  updateClearButtonVisibility() {
    if (!clearButton) return;
    
    if (searchInput && searchInput.value.length > 0) {
      clearButton.classList.remove('hidden');
    } else {
      clearButton.classList.add('hidden');
    }
  },

  // Save current state to session storage
  saveState() {
    sessionStorage.setItem('scrollPosition', window.pageYOffset);
    if (searchInput) sessionStorage.setItem('searchQuery', searchInput.value);
    if (langSelect) sessionStorage.setItem('selectedLang', langSelect.value);
    sessionStorage.setItem('returnedFromSong', 'true');
  },

  // Restore state from session storage
  restoreState() {
    const returnedFromSong = sessionStorage.getItem('returnedFromSong');
    if (returnedFromSong) {
      // Restore search query
      const savedQuery = sessionStorage.getItem('searchQuery');
      if (savedQuery && searchInput) {
        searchInput.value = savedQuery;
        this.updateClearButtonVisibility();
      }
      
      // Restore language selection
      const savedLang = sessionStorage.getItem('selectedLang');
      if (savedLang && langSelect && savedLang !== langSelect.value) {
        langSelect.value = savedLang;
        updateSongDisplay();
      }
      
      // Apply the filter to show only matching results
      // This must be called after restoring search query and language
      if (savedQuery && savedQuery.trim() !== '') {
        filterSongs();
        
        // Make sure text matches are shown
        setTimeout(() => {
          songItems.forEach(item => {
            const searchTerm = savedQuery.toLowerCase().trim();
            let textField;
            
            // Get the appropriate field based on language
            if (langSelect.value === 'ta') {
              textField = 'text';
            } else if (langSelect.value === 'en') {
              textField = 'textEn';
            } else if (langSelect.value === 'de') {
              textField = 'textDe';
            }
            
            // Check if this item has a text match
            const text = item.dataset[textField] ? 
              item.dataset[textField].toLowerCase() : 
              item.dataset.text.toLowerCase();
            
            // If there's a text match, show the context
            if (text.includes(searchTerm)) {
              const matchContext = item.querySelector('.match-context');
              if (matchContext) {
                const rawText = item.dataset[textField] || item.dataset.text || '';
                const context = findMatchContext(rawText, searchTerm);
                matchContext.innerHTML = highlightMatches(context, searchTerm);
                matchContext.classList.remove('hidden');
              }
            }
          });
        }, 50);
      }
      
      // Restore scroll position
      const savedPosition = sessionStorage.getItem('scrollPosition');
      if (savedPosition) {
        // Use setTimeout to ensure the scroll happens after the DOM is fully updated
        setTimeout(() => {
          window.scrollTo(0, parseInt(savedPosition));
        }, 100);
      }
      
      // Clear session storage
      this.clearState();
    }
  },

  // Clear state from session storage
  clearState() {
    sessionStorage.removeItem('returnedFromSong');
    sessionStorage.removeItem('scrollPosition');
    sessionStorage.removeItem('searchQuery');
    sessionStorage.removeItem('selectedLang');
  }
};

// Function to highlight text matches in a string
function highlightMatches(text, searchTerm) {
  if (!searchTerm || searchTerm.trim() === '' || !text) return text;
  
  const regex = new RegExp(`(${searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')})`, 'gi');
  return text.replace(regex, '<mark class="bg-yellow-200 text-gray-800">$1</mark>');
}

// Function to find the context around a match
function findMatchContext(text, searchTerm, contextLength = 50) {
  if (!searchTerm || searchTerm.trim() === '' || !text) return '';
  
  searchTerm = searchTerm.toLowerCase();
  const index = text.toLowerCase().indexOf(searchTerm);
  
  if (index === -1) return '';
  
  const start = Math.max(0, index - contextLength);
  const end = Math.min(text.length, index + searchTerm.length + contextLength);
  
  // Add ellipsis if we're not showing from the beginning or to the end
  const prefix = start > 0 ? '...' : '';
  const suffix = end < text.length ? '...' : '';
  
  return prefix + text.substring(start, end) + suffix;
}

// Reorder songs to show title matches first, then text matches
function reorderSongsByMatchPriority() {
  if (!songsList || !searchInput) return;
  
  const songItemsArray = Array.from(songItems);
  const searchTerm = searchInput.value.toLowerCase().trim();
  
  if (searchTerm === '') return;
  
  // Sort visible songs by match type (title matches first, then text matches)
  songItemsArray
    .filter(item => !item.classList.contains('hidden'))
    .sort((a, b) => {
      const aBadge = a.querySelector('.match-badge');
      const bBadge = b.querySelector('.match-badge');
      
      const aTitle = aBadge && aBadge.textContent.includes('Title') ? 1 : 0;
      const bTitle = bBadge && bBadge.textContent.includes('Title') ? 1 : 0;
      
      return bTitle - aTitle; // Title matches first
    })
    .forEach(item => {
      songsList.appendChild(item);
    });
}

// Update the filterSongs function to handle the new badge positioning and fix text formatting
function filterSongs() {
  if (!searchInput || !langSelect || !noResultsMessage) return;
  
  const searchTerm = searchInput.value.toLowerCase().trim();
  const selectedLang = langSelect.value;
  let visibleCount = 0;
  
  // First, hide all text snippets completely
  document.querySelectorAll('.song-item .relative').forEach(snippet => {
    snippet.classList.add('hidden');
  });
  
  songItems.forEach(item => {
    let titleField, textField;
    
    // Select the appropriate fields based on language
    if (selectedLang === 'ta') {
      titleField = 'title';
      textField = 'text';
    } else if (selectedLang === 'en') {
      titleField = 'titleEn';
      textField = 'textEn';
    } else if (selectedLang === 'de') {
      titleField = 'titleDe';
      textField = 'textDe';
    }
    
    // Get the appropriate data for the selected language
    // Fall back to Tamil if translation is missing
    const title = item.dataset[titleField] ? 
      item.dataset[titleField].toLowerCase() : 
      item.dataset.title.toLowerCase();
      
    const text = item.dataset[textField] ? 
      item.dataset[textField].toLowerCase() : 
      item.dataset.text.toLowerCase();
    
    const originalTitle = item.querySelector('.original-title');
    const matchBadge = item.querySelector('.match-badge');
    const matchContext = item.querySelector('.match-context');
    const matchTextEl = matchContext ? matchContext.querySelector('p') : null;
    
    const titleHit = searchTerm !== '' && title.includes(searchTerm);
    const textHit = searchTerm !== '' && text.includes(searchTerm);

    if (titleHit || textHit || searchTerm === '') {
      item.classList.remove('hidden');
      visibleCount++;
      
      // Handle search results
      if (searchTerm !== '') {
        // Show match badge with appropriate styling
        if (matchBadge) {
          matchBadge.classList.remove('hidden');
        
          if (titleHit) {
            matchBadge.textContent = 'Found in title';
            matchBadge.className = 'match-badge absolute top-1 left-1 z-20 text-[0.65rem] sm:text-xs font-medium px-1.5 py-0.5 sm:px-2 sm:py-1 rounded-md bg-blue-100 text-blue-800 bg-opacity-90 shadow-sm';
          } else {
            matchBadge.textContent = 'Found in text';
            matchBadge.className = 'match-badge absolute top-1 left-1 z-20 text-[0.65rem] sm:text-xs font-medium px-1.5 py-0.5 sm:px-2 sm:py-1 rounded-md bg-green-100 text-green-800 bg-opacity-90 shadow-sm';
          }
        }
        
        // Show match context for text hits
        if (textHit && matchTextEl) {
          const rawText = item.dataset[textField] || item.dataset.text || '';
          const context = findMatchContext(rawText, searchTerm);
          matchTextEl.innerHTML = highlightMatches(context, searchTerm);
          matchContext.classList.remove('hidden');
        } else if (matchContext) {
          matchContext.classList.add('hidden');
        }
        
        // Highlight title if there's a match
        if (titleHit && originalTitle) {
          const rawTitle = item.dataset[titleField] || item.dataset.title || '';
          originalTitle.innerHTML = highlightMatches(rawTitle, searchTerm);
        } else if (originalTitle) {
          // Use plain text for title when no title match
          originalTitle.textContent = item.dataset[titleField] || item.dataset.title || '';
        }
      } else {
        // Reset everything when no search term
        if (matchBadge) matchBadge.classList.add('hidden');
        if (matchContext) matchContext.classList.add('hidden');
        
        // Restore original title as plain text
        if (originalTitle) {
          originalTitle.textContent = item.dataset[titleField] || item.dataset.title || '';
        }
      }
    } else {
      item.classList.add('hidden');
    }
  });
  
  // Show/hide no results message
  noResultsMessage.classList.toggle('hidden', visibleCount > 0);
  
  // Reorder songs to prioritize title matches
  if (searchTerm !== '') {
    reorderSongsByMatchPriority();
  }
}

// Update song display based on selected language
function updateSongDisplay() {
  if (!langSelect) return;
  
  const selectedLang = langSelect.value;
  // Safe way to get base URL
  const baseUrl = window.location.pathname.includes('/songbook') ? 
                 '/songbook' : '';
  const searchTerm = searchInput ? searchInput.value.trim() : '';
  
  // Always hide text snippets
  document.querySelectorAll('.song-item .relative').forEach(snippet => {
    snippet.classList.add('hidden');
  });
  
  songItems.forEach(item => {
    const originalTitle = item.querySelector('.original-title');
    const translationTitle = item.querySelector('.translation-title');
    const matchContext = item.querySelector('.match-context');
    const link = item.querySelector('a');
    
    if (!originalTitle || !link) return;
    
    const songId = item.dataset.id;
    const originalTitleText = item.dataset.title;
    
    let displayTitle;
    
    // Set the appropriate titles based on language
    if (selectedLang === 'ta') {
      displayTitle = originalTitleText;
      if (translationTitle) translationTitle.classList.add('hidden');
      link.href = `${baseUrl}/songs/ta/${songId}`;
    } else if (selectedLang === 'en') {
      displayTitle = item.dataset.titleEn || originalTitleText;
      
      if (translationTitle && item.dataset.title && displayTitle !== originalTitleText) {
        translationTitle.textContent = `Original: ${originalTitleText}`;
        translationTitle.classList.remove('hidden');
      } else if (translationTitle) {
        translationTitle.classList.add('hidden');
      }
      
      link.href = `${baseUrl}/songs/en/${songId}`;
    } else if (selectedLang === 'de') {
      displayTitle = item.dataset.titleDe || originalTitleText;
      
      if (translationTitle && item.dataset.title && displayTitle !== originalTitleText) {
        translationTitle.textContent = `Original: ${originalTitleText}`;
        translationTitle.classList.remove('hidden');
      } else if (translationTitle) {
        translationTitle.classList.add('hidden');
      }
      
      link.href = `${baseUrl}/songs/de/${songId}`;
    }
    
    // Update text content (no highlights if not searching)
    if (searchTerm === '') {
      originalTitle.textContent = displayTitle;
      
      // Ensure match context is hidden
      if (matchContext) {
        matchContext.classList.add('hidden');
      }
    }
    
    // Preserve search query in links if there's an active search
    if (searchTerm) {
      const currentUrl = new URL(link.href, window.location.origin);
      currentUrl.searchParams.set('q', searchTerm);
      link.href = currentUrl.pathname + currentUrl.search;
    }
  });
  
  // When changing language, re-apply any active search filters
  if (searchInput && searchInput.value.trim() !== '') {
    filterSongs();
  }
}

// Helper function to restore original titles
function restoreOriginalTitles() {
  if (!langSelect) return;
  
  const selectedLang = langSelect.value;
  
  songItems.forEach(item => {
    let titleField;
    
    // Select the appropriate field based on language
    if (selectedLang === 'ta') {
      titleField = 'title';
    } else if (selectedLang === 'en') {
      titleField = 'titleEn';
    } else if (selectedLang === 'de') {
      titleField = 'titleDe';
    }
    
    const originalTitle = item.querySelector('.original-title');
    if (originalTitle) {
      // Use the plain text content without any HTML/highlights
      originalTitle.textContent = item.dataset[titleField] || item.dataset.title || '';
    }
  });
}

// Event Listeners
function setupEventListeners() {
  // Search input event
  if (searchInput) {
    searchInput.addEventListener('input', function() {
      state.updateClearButtonVisibility();
      filterSongs();
    });
  }
  
  // Clear button event
  if (clearButton) {
    clearButton.addEventListener('click', function() {
      if (searchInput) {
        searchInput.value = '';
        clearButton.classList.add('hidden');
      }
      
      // Explicitly hide all match contexts
      document.querySelectorAll('.match-context').forEach(context => {
        context.classList.add('hidden');
      });
      
      // Explicitly hide all match badges
      document.querySelectorAll('.match-badge').forEach(badge => {
        badge.classList.add('hidden');
      });
      
      // Hide all text snippets
      document.querySelectorAll('.song-item .relative').forEach(snippet => {
        snippet.classList.add('hidden');
      });
      
      // Restore original titles (without highlights)
      restoreOriginalTitles();
      
      // Reapply normal filtering
      filterSongs();
      
      // Focus the search input after clearing
      if (searchInput) searchInput.focus();
    });
  }
  
  // Language change event
  if (langSelect) {
    langSelect.addEventListener('change', function() {
      updateSongDisplay();
      
      // Hide all text-related elements when changing language (if not searching)
      if (!searchInput || searchInput.value.trim() === '') {
        document.querySelectorAll('.match-context').forEach(context => {
          context.classList.add('hidden');
        });
        
        document.querySelectorAll('.match-badge').forEach(badge => {
          badge.classList.add('hidden');
        });
        
        document.querySelectorAll('.song-item .relative').forEach(snippet => {
          snippet.classList.add('hidden');
        });
      } else {
        // Reapply search if there's an active search term
        filterSongs();
      }
    });
  }
  
  // Scroll event for "Go to Top" button
  if (goToTopButton) {
    window.addEventListener('scroll', function() {
      goToTopButton.classList.toggle('hidden', window.pageYOffset <= 300);
    });
    
    // Go to Top button click
    goToTopButton.addEventListener('click', function() {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });
  }
  
  // Save state when navigating to a song
  document.querySelectorAll('.song-item a').forEach(link => {
    link.addEventListener('click', function(e) {
      state.saveState();
    });
  });
  
  // Back/forward navigation handling
  window.addEventListener('popstate', function() {
    state.updateClearButtonVisibility();
    filterSongs();
  });
  
  // Add resize listener to handle search bar appearance on window resize
  window.addEventListener('resize', function() {
    // If the search input is focused, maintain the expanded state
    if (document.activeElement === searchInput) {
      if (searchContainer) {
        if (window.innerWidth >= 640) { // sm breakpoint
          searchContainer.classList.add('max-w-xl');
        } else {
          searchContainer.classList.remove('max-w-xl');
        }
      }
    }
  });
}

// Main initialization function
function init() {
  // Set up all event listeners
  setupEventListeners();
  
  // Setup search expansion functionality
  setupSearchExpansion();
  
  // Initialize song display
  updateSongDisplay();
  
  // Restore state if returning from a song
  state.restoreState();
  
  // Update clear button visibility (handles page reload cases)
  state.updateClearButtonVisibility();
  
  // Make sure no song text is shown on initial load
  document.querySelectorAll('.match-context').forEach(context => {
    context.classList.add('hidden');
  });
  
  // Hide all text snippets at startup
  document.querySelectorAll('.song-item .relative').forEach(snippet => {
    snippet.classList.add('hidden');
  });
  
  // Apply any active search on initial load
  if (searchInput && searchInput.value.trim() !== '') {
    filterSongs();
  }
}

// Run initialization when DOM is loaded
document.addEventListener('DOMContentLoaded', init);
    </script>
  </body>
</html>
